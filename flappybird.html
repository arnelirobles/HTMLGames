<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy Bird - Local Rankings</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #333;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            background-color: #70c5ce;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .score-display {
            position: absolute;
            top: 10%;
            font-size: 4rem;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            z-index: 10;
            pointer-events: none;
        }

        .message-box {
            background: rgba(255, 255, 255, 0.95);
            border: 4px solid #543847;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 300px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            /* Allow scrolling if leaderboard is long on small screens */
        }

        .message-box h1 {
            margin: 0;
            color: #543847;
            font-size: 2rem;
        }

        .message-box h2 {
            margin: 10px 0 5px 0;
            color: #e06020;
            font-size: 1.5rem;
        }

        .message-box p {
            font-size: 1.2rem;
            color: #333;
            margin: 0 0 10px 0;
        }

        /* Input for Player Name */
        #player-name-input {
            padding: 10px;
            font-size: 1.1rem;
            border: 2px solid #543847;
            border-radius: 5px;
            width: 80%;
            text-align: center;
            margin-bottom: 10px;
            outline: none;
            font-weight: bold;
            text-transform: uppercase;
        }

        #player-name-input:focus {
            border-color: #e06020;
        }

        .btn {
            background: #e06020;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1rem;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            border-bottom: 4px solid #b04010;
            transition: transform 0.1s;
        }

        .btn:active {
            transform: translateY(4px);
            border-bottom: 0;
        }

        /* Leaderboard Table */
        .leaderboard {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 1rem;
        }

        .leaderboard th {
            background: #543847;
            color: white;
            padding: 5px;
        }

        .leaderboard td {
            border-bottom: 1px solid #ddd;
            padding: 5px;
            color: #333;
        }

        .leaderboard tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        /* Highlight current run */
        .highlight-run {
            background-color: #fff3cd !important;
            font-weight: bold;
        }

        .instruction {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #666;
        }
    </style>
</head>

<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="score" class="score-display">0</div>

        <!-- Start Screen -->
        <div id="start-screen" class="message-box" style="display: flex;">
            <h1>Flappy Bird</h1>
            <p>Enter your name:</p>
            <input type="text" id="player-name-input" placeholder="PLAYER 1" maxlength="8" autocomplete="off">
            <button class="btn" id="start-btn">Play</button>
            <div class="instruction">Tap, Click, or Spacebar to Jump</div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="message-box">
            <h1>Game Over</h1>
            <p>Score: <span id="final-score">0</span></p>

            <h2>Rankings</h2>
            <table class="leaderboard">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Name</th>
                        <th>Score</th>
                    </tr>
                </thead>
                <tbody id="leaderboard-body">
                    <!-- Rows injected via JS -->
                </tbody>
            </table>

            <br>
            <button class="btn" id="restart-btn">Try Again</button>
        </div>
    </div>

    <script>

        /**
         * Game Logic
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // UI Elements
        const scoreEl = document.getElementById('score');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        const nameInput = document.getElementById('player-name-input');
        const leaderboardBody = document.getElementById('leaderboard-body');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');

        // Game State Enum
        const STATE = {
            START: 0,
            PLAYING: 1,
            GAMEOVER: 2
        };

        let currentState = STATE.START;
        let frames = 0;
        let score = 0;
        let currentPlayerName = "Player 1";

        // Default Colors
        const colors = {
            sky: "#70c5ce",
            ground: "#ded895",
            grass: "#73bf2e",
            cloud: "rgba(255, 255, 255, 0.6)",
            birdBody: "#f4ce42",
            birdWing: "#f7e396",
            birdBeak: "#f76808",
            birdEye: "#fff",
            pipeBody: "#73bf2e",
            pipeBorder: "#000"
        };

        // Responsive Canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- Leaderboard Logic (LocalStorage) ---

        const LEADERBOARD_KEY = 'flappyLeaderboard_v1';

        function saveScore(name, points) {
            // 1. Get existing data
            let data = localStorage.getItem(LEADERBOARD_KEY);
            let scores = data ? JSON.parse(data) : [];

            // Normalize name (trim and default)
            const cleanName = (name || "Anonymous").trim();

            // 2. Check if player exists
            // Find index of player with same name (case-insensitive)
            const existingIndex = scores.findIndex(s => s.name.toLowerCase() === cleanName.toLowerCase());

            let currentEntry = null;

            if (existingIndex !== -1) {
                // Player exists in leaderboard
                if (points > scores[existingIndex].score) {
                    // New Personal Best! Update the score and timestamp
                    scores[existingIndex].score = points;
                    scores[existingIndex].ts = Date.now();
                    scores[existingIndex].name = cleanName; // Update casing if changed
                    currentEntry = scores[existingIndex];
                } else {
                    // Did not beat previous high score
                    // Create a dummy entry for the current run just to return it, 
                    // but DO NOT modify the leaderboard array.
                    currentEntry = {
                        name: cleanName,
                        score: points,
                        ts: Date.now()
                    };
                }
            } else {
                // New Player (or not previously in leaderboard)
                currentEntry = {
                    name: cleanName,
                    score: points,
                    ts: Date.now()
                };
                scores.push(currentEntry);
            }

            // 3. Sort descending
            scores.sort((a, b) => b.score - a.score);

            // 4. Keep top 5
            scores = scores.slice(0, 5);

            // 5. Save back
            localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(scores));

            return currentEntry;
        }

        function updateLeaderboardUI(currentRunEntry) {
            let data = localStorage.getItem(LEADERBOARD_KEY);
            let scores = data ? JSON.parse(data) : [];

            leaderboardBody.innerHTML = ""; // Clear old rows

            if (scores.length === 0) {
                leaderboardBody.innerHTML = "<tr><td colspan='3'>No scores yet!</td></tr>";
                return;
            }

            scores.forEach((entry, index) => {
                const tr = document.createElement('tr');

                // Highlight if this is the run we just finished
                // Using timestamp match for uniqueness
                if (currentRunEntry && entry.ts === currentRunEntry.ts && entry.name === currentRunEntry.name) {
                    tr.classList.add('highlight-run');
                }

                tr.innerHTML = `
            <td>${index + 1}</td>
            <td>${entry.name}</td>
            <td>${entry.score}</td>
        `;
                leaderboardBody.appendChild(tr);
            });
        }

        // --- Assets / Drawing Functions ---

        const clouds = [];
        function initClouds() {
            clouds.length = 0;
            for (let i = 0; i < 5; i++) {
                clouds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height / 2),
                    w: 60 + Math.random() * 40,
                    s: 0.5 + Math.random() * 0.5
                });
            }
        }

        function drawBackground() {
            ctx.fillStyle = colors.sky;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = colors.cloud;
            clouds.forEach(c => {
                c.x -= c.s;
                if (c.x + c.w < 0) c.x = canvas.width + c.w;

                ctx.beginPath();
                ctx.arc(c.x, c.y, c.w / 2, 0, Math.PI * 2);
                ctx.arc(c.x + c.w * 0.4, c.y - c.w * 0.2, c.w * 0.4, 0, Math.PI * 2);
                ctx.arc(c.x + c.w * 0.8, c.y, c.w / 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Ground
            ctx.fillStyle = colors.ground;
            ctx.fillRect(0, canvas.height - 100, canvas.width, 100);

            // Grass top
            ctx.fillStyle = colors.grass;
            ctx.fillRect(0, canvas.height - 100, canvas.width, 15);

            // Moving strip on ground to show speed
            ctx.fillStyle = "rgba(0,0,0,0.1)";
            const stripWidth = 20;
            const offset = (frames * 2) % stripWidth;
            for (let i = -1; i < canvas.width / stripWidth + 1; i++) {
                ctx.fillRect((i * stripWidth) - offset, canvas.height - 95, 2, 10);
            }
        }

        // --- Game Entities ---

        const bird = {
            x: 50,
            y: 150,
            w: 34,
            h: 24,
            radius: 12,
            velocity: 0,
            gravity: 0.25,
            jump: -4.6,
            rotation: 0,

            draw: function () {
                ctx.save();
                ctx.translate(this.x, this.y);
                // Rotate based on velocity
                this.rotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, (this.velocity * 0.1)));

                ctx.rotate(this.rotation);

                // Body
                ctx.fillStyle = colors.birdBody;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius * 1.3, this.radius, 0, 0, Math.PI * 2);
                ctx.fill();

                // Border
                ctx.lineWidth = 2;
                ctx.strokeStyle = "#000";
                ctx.stroke();

                // Eye
                ctx.fillStyle = colors.birdEye;
                ctx.beginPath();
                ctx.arc(6, -6, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Pupil
                ctx.fillStyle = "#000";
                ctx.beginPath();
                ctx.arc(8, -6, 2, 0, Math.PI * 2);
                ctx.fill();

                // Beak
                ctx.fillStyle = colors.birdBeak;
                ctx.beginPath();
                ctx.moveTo(8, 2);
                ctx.lineTo(16, 6);
                ctx.lineTo(8, 10);
                ctx.fill();
                ctx.stroke();

                // Wing
                ctx.fillStyle = colors.birdWing;
                ctx.beginPath();
                ctx.ellipse(-6, 2, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            },

            update: function () {
                this.velocity += this.gravity;
                this.y += this.velocity;

                // Floor collision
                if (this.y + this.radius >= canvas.height - 100) {
                    this.y = canvas.height - 100 - this.radius;
                    gameOver();
                }

                // Ceiling collision
                if (this.y - this.radius <= 0) {
                    this.y = this.radius;
                    this.velocity = 0;
                }
            },

            flap: function () {
                this.velocity = this.jump;
            },

            reset: function () {
                this.x = canvas.width / 4;
                this.y = canvas.height / 2;
                this.velocity = 0;
                this.rotation = 0;
            }
        };

        const pipes = {
            position: [],
            w: 52,
            gap: 150,
            dx: 2.5,

            draw: function () {
                for (let i = 0; i < this.position.length; i++) {
                    let p = this.position[i];
                    let topY = p.y;
                    let bottomY = p.y + this.gap;

                    ctx.fillStyle = colors.pipeBody;
                    ctx.strokeStyle = colors.pipeBorder;
                    ctx.lineWidth = 2;

                    // Draw Top Pipe
                    ctx.fillRect(p.x, 0, this.w, topY);
                    ctx.strokeRect(p.x, 0, this.w, topY);
                    ctx.fillRect(p.x - 2, topY - 20, this.w + 4, 20);
                    ctx.strokeRect(p.x - 2, topY - 20, this.w + 4, 20);

                    // Draw Bottom Pipe
                    ctx.fillRect(p.x, bottomY, this.w, canvas.height - 100 - bottomY);
                    ctx.strokeRect(p.x, bottomY, this.w, canvas.height - 100 - bottomY);
                    ctx.fillRect(p.x - 2, bottomY, this.w + 4, 20);
                    ctx.strokeRect(p.x - 2, bottomY, this.w + 4, 20);
                }
            },

            update: function () {
                const currentSpawnRate = Math.floor(300 / this.dx);

                if (frames % currentSpawnRate === 0) {
                    const minPipe = 50;
                    const maxPos = canvas.height - 100 - this.gap - minPipe;
                    const y = Math.floor(Math.random() * (maxPos - minPipe + 1)) + minPipe;

                    this.position.push({
                        x: canvas.width,
                        y: y,
                        passed: false
                    });
                }

                for (let i = 0; i < this.position.length; i++) {
                    let p = this.position[i];
                    p.x -= this.dx;

                    // Collision detection
                    const birdLeft = bird.x - bird.radius + 4;
                    const birdRight = bird.x + bird.radius - 4;
                    const birdTop = bird.y - bird.radius + 4;
                    const birdBottom = bird.y + bird.radius - 4;

                    const pipeLeft = p.x;
                    const pipeRight = p.x + this.w;
                    const topPipeBottom = p.y;
                    const bottomPipeTop = p.y + this.gap;

                    if (birdRight > pipeLeft && birdLeft < pipeRight) {
                        if (birdTop < topPipeBottom || birdBottom > bottomPipeTop) {
                            gameOver();
                        }
                    }

                    if (p.x + this.w < bird.x && !p.passed) {
                        score++;
                        p.passed = true;
                        scoreEl.innerText = score;
                    }

                    if (p.x + this.w <= 0) {
                        this.position.shift();
                        i--;
                    }
                }
            },

            reset: function () {
                this.position = [];
                this.dx = 2.5;
            }
        };


        // --- Game Loop ---

        function update() {
            if (currentState === STATE.PLAYING) {
                bird.update();
                pipes.update();
            } else if (currentState === STATE.START) {
                bird.y = canvas.height / 2 + Math.sin(frames * 0.1) * 5;
                bird.x = canvas.width / 2;
                bird.rotation = 0;
            }
            frames++;
        }

        function draw() {
            drawBackground();
            pipes.draw();
            bird.draw();
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        // --- State Management ---

        function startGame() {
            const inputVal = nameInput.value.trim();
            currentPlayerName = inputVal.length > 0 ? inputVal : "Anonymous";

            currentState = STATE.PLAYING;
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            scoreEl.style.display = 'block';
            score = 0;
            scoreEl.innerText = score;
            bird.reset();
            pipes.reset();
            frames = 0;
        }

        function gameOver() {
            if (currentState === STATE.GAMEOVER) return; // Prevent double trigger
            currentState = STATE.GAMEOVER;

            finalScoreEl.innerText = score;

            // Save and display leaderboards
            const currentRun = saveScore(currentPlayerName, score);
            updateLeaderboardUI(currentRun);

            scoreEl.style.display = 'none';
            gameOverScreen.style.display = 'flex';
        }

        // --- Input Handling ---

        function inputAction(e) {
            // Don't flap if interacting with input or buttons
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
            if (e.type === 'keydown' && e.code !== 'Space') return;

            if (e.type === 'keydown') e.preventDefault();
            if (e.type === 'touchstart') e.preventDefault();

            switch (currentState) {
                case STATE.START:
                    // Removed direct start from tapping background to force using button for name entry
                    // or we could just focus input. Let's require button press.
                    break;
                case STATE.PLAYING:
                    bird.flap();
                    break;
                case STATE.GAMEOVER:
                    break;
            }
        }

        // Event Listeners
        window.addEventListener('keydown', inputAction);
        window.addEventListener('mousedown', inputAction);
        window.addEventListener('touchstart', inputAction, { passive: false });

        startBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            startGame();
        });

        restartBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            // Reset game state for replay
            currentState = STATE.START;
            gameOverScreen.style.display = 'none';
            startScreen.style.display = 'flex';
            scoreEl.style.display = 'block';
            bird.reset();
            // Don't reset score text yet, looks nicer to see 0 on start
            scoreEl.innerText = 0;
        });

        // Init
        initClouds();
        loop();

    </script>
</body>

</html>